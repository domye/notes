## HashMap 的底层数据结构

JDK 8 中 HashMap 的数据结构是`数组`+`链表`+`红黑树`。

![](https://cdn.domye.top/uploads/08/1755935554.webp)

数组用来存储键值对，每个键值对可以通过索引直接拿到，索引是通过对键的哈希值进行进一步的 `hash()` 处理得到的。

当多个键经过哈希处理后得到相同的索引时，需要通过链表来解决哈希冲突——将具有相同索引的键值对通过链表存储起来。

不过，链表过长时，查询效率会比较低，于是当链表的长度超过 8 时（且数组的长度大于 64），链表就会转换为红黑树。红黑树的查询效率是 O(logn)，比链表的 O(n) 要快。

`hash()` 方法的目标是尽量减少哈希冲突，保证元素能够均匀地分布在数组的每个位置上。

```java
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

如果键的哈希值已经在数组中存在，其对应的值将被新值覆盖。

HashMap 的初始容量是 16，随着元素的不断添加，HashMap 就需要进行扩容，阈值是`capacity * loadFactor`，capacity 为容量，loadFactor 为负载因子，默认为 0.75。

扩容后的数组大小是原来的 2 倍，然后把原来的元素重新计算哈希值，放到新的数组中。

## HashMap 的 put 流程

哈希寻址 → 处理哈希冲突（链表还是红黑树）→ 判断是否需要扩容 → 插入/覆盖节点。

![](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/sidebar/sanfene/collection-13.jpg)

HashMap HashMap的put()方法用于向HashMap中添加键值对，当调用HashMap的put()方法时，会按照以下详细流程执行（JDK8 1.8版本）：

1. 根据要添加的键的哈希码计算在数组中的位置（索引）。

2. 检查该位置是否为空（即没有键值对存在）
   - 如果为空，则直接在该位置创建一个新的Entry对象来存储键值对
   - 将要添加的键值对作为该Entry的键和值，并保存在数组的对应位置
   - 将HashMap的修改次数（modCount）加1，以便在进行迭代时发现并发修改

3. 如果该位置已经存在其他键值对，检查该位置的第一个键值对的哈希码和键是否与要添加的键值对相同
   - 如果相同，则表示找到了相同的键，直接将新的值替换旧的值，完成更新操作。

4. 如果第一个键值对的哈希码和键不相同，则需要遍历链表或红黑树来查找是否有相同的键：

   如果键值对集合是链表结构，从链表的头部开始逐个比较键的哈希码和equals()方法，直到找到相同的键或达到链表末尾。

   - 如果找到了相同的键，则使用新的值取代旧的值，即更新键对应的值。

   - 如果没有找到相同的键，则将新的键值对添加到链表的头部。

   如果键值对集合是红黑树结构，在红黑树中使用哈希码和equals()方法进行查找。根据键的哈希码，定位到红黑树中的某个节点，然后逐个比较键，直到找到相同的键或达到红黑树末尾。

   - 如果找到了相同的键，则使用新的值取代旧的值，即更新键对应的值。
   - 如果没有找到相同的键，则将新的键值对添加到红黑树中。

5. 检查链表长度是否达到阈值（默认为8）
   - 如果链表长度超过阈值，且HashMap的数组长度大于等于64，则会将链表转换为红黑树，以提高查询效率。

6. 检查负载因子是否超过阈值（默认为0.75）：
   - 如果键值对的数量（size）与数组的长度的比值大于阈值，则需要进行扩容操作。

7. 扩容操作

   - 创建一个新的两倍大小的数组。

   - 将旧数组中的键值对重新计算哈希码并分配到新数组中的位置。

   - 更新HashMap的数组引用和阈值参数。

8. 完成添加操作。

## HashMap 是线程安全的吗？

HashMap 不是线程安全的，主要有以下几个问题：

①、多线程下扩容会死循环。JDK7 中的 HashMap 使用的是头插法来处理链表，在多线程环境下扩容会出现环形链表，造成死循环。

![](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/collection/hashmap-thread-nosafe-07.png)

不过，JDK 8 时通过尾插法修复了这个问题，扩容时会保持链表原来的顺序。

②、多线程在进行 put 元素的时候，可能会导致元素丢失。因为计算出来的位置可能会被其他线程覆盖掉，比如说一个线程put 3 的时候，另外一个线程 put 了 7，就把 3 给弄丢了。

![](https://cdn.tobebetterjavaer.com/tobebetterjavaer/images/collection/hashmap-thread-nosafe-10.png)

③、put 和 get 并发时，可能导致 get 为 null。线程 1 执行 put 时，因为元素个数超出阈值而扩容，线程 2 此时执行 get，就有可能出现这个问题。

因为线程 1 执行完 table = newTab 之后，线程 2 中的 table 已经发生了改变，比如说索引 3 的键值对移动到了索引 7 的位置，此时线程 2 去 get 索引 3 的元素就 get 不到了。

## HashMap 和 Hashtable 的区别

- **线程是否安全：** `HashMap` 是非线程安全的，`Hashtable` 是线程安全的,因为 `Hashtable` 内部方法基本都经过`synchronized` 修饰
- **效率：** 因为线程安全的问题，`HashMap` 要比 `Hashtable` 效率高一点。另外，`Hashtable` 基本被淘汰，不要在代码中使用它
- **对 Null key 和 Null value 的支持：** `HashMap` 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；Hashtable 不允许有 null 键和 null 值，否则会抛出 `NullPointerException`
- **初始容量大小和每次扩充容量大小的不同：**
  1. 创建时如果不指定容量初始值，`Hashtable` 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。`HashMap` 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。
  2. 创建时如果给定了容量初始值，那么 `Hashtable` 会直接使用你给定的大小，而 `HashMap` 会将其扩充为 2 的幂次方大小。也就是说 `HashMap` 总是使用 2 的幂作为哈希表的大小

- **底层数据结构：** JDK1.8 以后的 `HashMap` 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树），以减少搜索时间。`Hashtable` 没有这样的机制
- **哈希函数的实现**：`HashMap` 对哈希值进行了高位和低位的混合扰动处理以减少冲突，而 `Hashtable` 直接使用键的 `hashCode()` 值



## HashMap的大小为什么是2的n次方大小呢？

### 高效计算索引：`hash & (length - 1)` 替代取模

通常需要通过哈希值计算键值对的存储位置（索引），公式为： **`index = hash(key) % capacity`** 但取模运算（`%`）效率较低。

当容量为 2 的幂次方时，`n - 1` 的二进制形式是全 `1`（例如 `16 - 1 = 15` 的二进制是 `1111`）。此时可以用**位与运算**（`&`）替代取模： **`index = hash(key) & (capacity - 1)`** 位运算的效率远高于取模

假设哈希值为 `42`，容量为 `16`：

```java
int hash = 42;       // 二进制: 00101010
int capacity = 16;   // capacity - 1 = 15 (二进制: 00001111)
int index = hash & (capacity - 1);

// 计算过程:
//   00101010 (42)
// & 00001111 (15)
//   --------
//   00001010 (10)
System.out.println(index); // 输出: 10
```

### 2. 减少哈希冲突，均匀分布

如果容量不是 2 的幂次方，`capacity - 1` 的二进制中会有 `0` 位（例如 `15 - 1 = 14` 的二进制是 `1110`）。这会导致哈希值的某些位永远无法参与索引计算（例如 `1110 & hash` 会忽略哈希值的最后一位），增加冲突概率。

2 的幂次方容量能确保 `capacity - 1` 的二进制全是 `1`，从而让哈希值的所有低位都参与运算，分布更均匀。

### 3. 扩容时高效重新哈希

HashMap 扩容时（如从 `16` 扩容到 `32`），需要重新计算键值对的位置。如果容量是 2 的幂次方，新索引可以通过以下方式快速计算： **`newIndex = oldIndex | (oldCapacity)`** 例如，原索引为 `5`（二进制 `0101`），扩容后新索引可能是 `5` 或 `21`（`0101 | 10000 = 10101`）。这种设计避免了重新哈希计算，提升了扩容效率。

### 4. **与哈希函数配合优化**

HashMap 的 `hash()` 方法会对键的原始哈希值进行二次扰动（如异或高16位），以减少哈希碰撞。当容量为 2 的幂次方时，扰动后的哈希值能更均匀地映射到数组中。